1. Understandable - abstractions are created for sake of simplification of complexity.
2. Debuggable - call stack is not ridiculous, one man should be enough to understand and explain why/what is happening.
3. Modifiable/extensible - finding how/where adding modifications should be guided by code; fear to break is detremental.
4. Fast to build - our machines are super computers, the only reason something builds longer than 10 seconds is low quality build process or million dependencies.
5. Performant - time is most precious thing we have but is not valued because we have plenty of it, but every second you delay, every code user gets compounded delay.
6. Testable - code is easy to write tests for.

Writing code to solve the problem is the easiest part. Hard part is to maintain aforementioned qualities. Every problem is data transformation problem, thus every problem is a math problem. If you know your problem you can solve it with one liner, but normally we don't do that, we rather create abstractions to help seprate problem steps. 

In order to achieve a one line solution first we need to solve it with many steps and then we can optimize it, but if problem changes your one liner is useless, but hopefully you don't need to modify it too much. But what if we could solve the problem in any way we want and then it would be converted to one liner?

Human is a product is such problem. For different systems we have different operation methods. Nerves are straight, to the point, fast, simple, instant. Blood is a constant flow, but only taken as much as needed. Evolution had to use time to improve/change each iteration, we don't have time, but we can run stupendous amount of iterations to achieve that one-liner, that perfect solution.

Problems to solve:
1. Output of such solution would be hardly understandable.
2. Source maps, or something, would be helpful?

Benefits:
1. Output would be small and fast.